{"id":477,"date":"2021-10-26T21:59:21","date_gmt":"2021-10-26T21:59:21","guid":{"rendered":"https:\/\/shichengzhang.web.illinois.edu\/?page_id=477"},"modified":"2021-10-29T04:39:21","modified_gmt":"2021-10-29T04:39:21","slug":"ac-musica","status":"publish","type":"page","link":"https:\/\/shichengzhang.web.illinois.edu\/ac-musica\/","title":{"rendered":"Algorithmic Composition- Musica"},"content":{"rendered":"\n<p>Abstract:<\/p>\n\n\n\n<p>Muisca is an algorithmic composition that can generate functional four-part harmony based on the prescribed tessitura for each voice. Inside the algorithm, I implement multiple finite state machines with the probabilistic approach in different musical parameters controlling the transition of chord function(T, PD, D), scale degree(I, V, IV, etc.), and voice-leading rules(voice crossing, leap-recovery rule in melody, etc.). The aesthetic consideration of the generative algorithm is referred to a four-part chorale I composed, which is also attached below.<\/p>\n\n\n\n<p>Music:<\/p>\n\n\n\n<figure class=\"wp-block-audio\"><audio controls src=\"https:\/\/shichengzhang.web.illinois.edu\/wp-content\/uploads\/2021\/10\/counterpoint_original.mp3\"><\/audio><figcaption>A chorale I compose as the prototype<\/figcaption><\/figure>\n\n\n\n<figure class=\"wp-block-audio\"><audio controls src=\"https:\/\/shichengzhang.web.illinois.edu\/wp-content\/uploads\/2021\/10\/counterpoint_5min.mp3\"><\/audio><figcaption>A nine-minute version of the Musica<\/figcaption><\/figure>\n\n\n\n<figure class=\"wp-block-video\"><video height=\"1080\" style=\"aspect-ratio: 1856 \/ 1080;\" width=\"1856\" controls src=\"https:\/\/shichengzhang.web.illinois.edu\/wp-content\/uploads\/2021\/10\/counterpoint.flp-FL-Studio-20-2021-03-05-21-14-26.mp4\"><\/video><figcaption>A one-minute example of Musica<\/figcaption><\/figure>\n\n\n\n<div class=\"wp-block-file\"><a href=\"https:\/\/shichengzhang.web.illinois.edu\/wp-content\/uploads\/2021\/10\/baroque.mid\">Musica_fragment_midi<\/a><a href=\"https:\/\/shichengzhang.web.illinois.edu\/wp-content\/uploads\/2021\/10\/baroque.mid\" class=\"wp-block-file__button\" download>Download<\/a><\/div>\n\n\n\n<p>Code:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># Musx is an algorithmic compostion framework created by Professor Heinrick Taube at UIUC \n# Install musx package through pip install musx \n\n# Import info and some functions are omitted, if you need source code, please contact: sz18@illinois.edu, Benny Zhang\n\n\ndef s_elasticity_valid(l_notes, scope=4):\n    l = l_notes \n    if scope == 4:\n        # normalized\n        # extract the last three\n        l = &#91;abs(pitch - l&#91;0]) for pitch in l&#91;0:4]]\n        # Pythagorian rules for triangle\n        if ((l&#91;1] + l&#91;2]) &gt; l&#91;3]) or ((l&#91;1] + l&#91;3]) &gt; l&#91;2]) or ((l&#91;2] + l&#91;3]) &gt; l&#91;1]):\n            return True\n        else:\n            return False \n    elif scope == 8:\n        l = &#91;abs(pitch - l&#91;0]) for pitch in l&#91;0:8]]\n         # Pythagorian rules for triangle for first 4 notes\n        if ((l&#91;1] + l&#91;2]) &gt; l&#91;3]) or ((l&#91;1] + l&#91;3]) &gt; l&#91;2]) or ((l&#91;2] + l&#91;3]) &gt; l&#91;1]):\n            if l&#91;7]-l&#91;0] &lt; 5:\n                return True\n        else:\n            return False \n\ndef generate_cp():\n    '''\n    This is the meta seeds generating the whole corpus\n    '''\n    key = 60 - 1; form_num = 4\n    # this is the piano roll for each voice\n    s = &#91;0 for i in range(3*8*2*form_num)]\n    a = &#91;0 for i in range(3*8*2*form_num)]\n    t = &#91;0 for i in range(3*8*2*form_num)]\n    b = &#91;0 for i in range(3*8*2*form_num)]\n    # scale \n    tonic_scale = &#91;0,2,4,5,7,9,11]; dom_scalee = &#91;0,2,4,6,7,9,11]; sec_dom_scale = &#91;1,2,4,6,7,9,11]\n    t_s_chord = &#91;\\\n        &#91;0,4,7,12], &#91;2,5,9,12], &#91;4,7,11,14], &#91;5,9,12,16],&#91;7,11,14,17]\n        ]\n    c_64_chord = &#91;&#91;7-12, 0, 4, 7]]\n    DD_chord = &#91;&#91;2, 6, 9, 12]]\n    # the function the index number of t_s_chord\n    T = &#91;t_s_chord&#91;0]]; PD = &#91;t_s_chord&#91;1], t_s_chord&#91;3]]; D = &#91;t_s_chord&#91;4]]; m = &#91;t_s_chord&#91;2]]\n\n    # first of all, generate the canctum firmus in soprano, and then the first species bass\n    # canctus firmus sentence phrase model\n    # Remember the first and last 2 chords only in roots position\n    cf_s_p_m = &#91;T, PD, D, T,   PD, choice(&#91;DD_chord,PD]), c_64_chord, D]\n    cf_s_p_m_det = &#91;choice(cf_s_p_m&#91;i]) for i in range(len(cf_s_p_m))]\n    # concept of elasticity in the melody, 4 prime notes as a circle\n    cf = &#91;];range_lower = -7; range_higher = 14\n    cf.append(choice(cf_s_p_m_det&#91;0]&#91;:2]))\n    while True:\n        #print(\"yes\")\n        for i in range(1,8):\n            note_selection = &#91;]\n            # three stands for 3 octaves range\n            chord = cf_s_p_m_det&#91;i]\n            #print(chord)\n            for j in range(3):\n                for item in chord:\n                    note_selection.append(item - 12 + j * 12)\n            # now get rid of redundant notes\n            notes_selection_clear = &#91;]\n            for item in note_selection:\n                if item &gt; range_lower and item &lt; range_higher:\n                    notes_selection_clear.append(item)\n\n            # now get the previous note of the melody, and if it is &lt; 5 100% accept, if &gt;5 &lt; 10, 60% accept, other 0% accept\n            prev = cf&#91;-1]\n            while True:\n                note = choice(notes_selection_clear)\n                if (note - prev) == -5 or (note - prev) == 7:\n                    continue\n                elif abs(note - prev) &lt; 5:\n                    escape = choice(&#91;1])\n                    if escape == 1:\n                        break\n                elif abs(note - prev) &gt; 5 and abs(note - prev) &lt; 7:\n                    escape = choice(&#91;1,1,1,0,0])\n                    if escape == 1:\n                        break\n            cf.append(note)\n            \n        cf = cf \n        ela = choice(&#91;4,8])\n        #print(ela)\n        if ela == 4:\n            if s_elasticity_valid(cf&#91;0:4],4) and s_elasticity_valid(cf&#91;4:8],4):\n                break\n        else:\n            if s_elasticity_valid(cf,8):\n                break\n        cf = cf&#91;:1]\n\n    # ==================== CF  Melody done! ====================  \n\n    # === now go to the bass line =================\n    cf = cf \n    #print(f\"{cf} this is cf\")\n    bass_voice = &#91;];range_lower = -6; range_higher = 10\n    bass_voice.append(cf_s_p_m_det&#91;0]&#91;0])\n    while True:\n        #print(\"yes\")\n        for i in range(1,8-2):\n            note_selection = &#91;]\n            # three stands for 3 octaves range\n            chord = cf_s_p_m_det&#91;i]\n            #print(chord)\n            for j in range(3):\n                for item in chord:\n                    note_selection.append(item - 12 + j * 12)\n            # now get rid of redundant notes\n            notes_selection_clear = &#91;]\n            for item in note_selection:\n                if item &gt; range_lower and item &lt; range_higher:\n                    notes_selection_clear.append(item)\n\n            # now get the previous note of the melody, and if it is &lt; 5 100% accept, if &gt;5 &lt; 10, 60% accept, other 0% accept\n            prev = bass_voice&#91;-1]\n            while True:\n                note = choice(notes_selection_clear)\n                if abs(note - prev) &lt; 5:\n                    escape = choice(&#91;1])\n                    if escape == 1:\n                        break\n                elif abs(note - prev) &gt; 5 and abs(note - prev) &lt; 7:\n                    escape = choice(&#91;1,1,1,0,0])\n                    if escape == 1:\n                        break\n            bass_voice.append(note)\n        for i in range(6,8):\n            note_selection = &#91;]\n            # three stands for 3 octaves range\n            chord = cf_s_p_m_det&#91;i]\n            #print(chord)\n            for j in range(3):\n                note_selection.append(chord&#91;0] - 12 + j * 12)\n            # now get rid of redundant notes\n            notes_selection_clear = &#91;]\n            for item in note_selection:\n                if item &gt; range_lower and item &lt; range_higher:\n                    notes_selection_clear.append(item)\n\n            # now get the previous note of the melody, and if it is &lt; 5 100% accept, if &gt;5 &lt; 10, 60% accept, other 0% accept\n            prev = bass_voice&#91;-1]\n            while True:\n                note = choice(notes_selection_clear)\n                if abs(note - prev) &lt; 5:\n                    escape = choice(&#91;1])\n                    if escape == 1:\n                        break\n                elif abs(note - prev) &gt; 5 and abs(note - prev) &lt; 10:\n                    escape = choice(&#91;1,0,0,0,0])\n                    if escape == 1:\n                        break\n            bass_voice.append(note)\n        \n        bass_voice = bass_voice\n        ela = choice(&#91;4,8])\n        #print(ela)\n        if ela == 4:\n            if s_elasticity_valid(bass_voice&#91;0:4],4) and s_elasticity_valid(bass_voice&#91;4:8],4):\n                break\n        else:\n            if s_elasticity_valid(bass_voice,8):\n                break\n        bass_voice = bass_voice&#91;:1]\n    #print(f\"{bass_voice} this is bass_voice \")\n    # go to the octave where the bass should be!\n    bass_voice = &#91;item - 24 for item in bass_voice]\n    # ==================== Bass  Melody done! ====================  \n\n    # ==== Now go to the alto line =====================================\n    cf = cf; bass_voice = bass_voice\n    alto_voice = &#91;];range_lower = -6; range_higher = 7\n    while True:\n        #print(\"yes\")\n        alto_voice.append(choice(cf_s_p_m_det&#91;0]&#91;:3])-12)\n        for i in range(1,8):\n            note_selection = &#91;]\n            # three stands for 3 octaves range\n            chord = cf_s_p_m_det&#91;i]\n            #print(chord)\n            for j in range(3):\n                for item in chord:\n                    note_selection.append(item - 24 + j * 12)\n            # now get rid of redundant notes\n            notes_selection_clear = &#91;]\n            for item in note_selection:\n                if item &gt; (bass_voice&#91;i]+7) and item &lt; cf&#91;i]:\n                    notes_selection_clear.append(item)\n\n            # now get the previous note of the melody, and if it is &lt; 5 100% accept, if &gt;5 &lt; 10, 60% accept, other 0% accept\n            prev = alto_voice&#91;-1]\n            count = 0\n            while True:\n                #print(f\"{notes_selection_clear} this isnotes_selection_clear\")\n                note = choice(notes_selection_clear)\n                if abs(note - prev) &lt; 5:\n                    escape = choice(&#91;1])\n                    if escape == 1:\n                        break\n                elif abs(note - prev) &gt; 5 and abs(note - prev) &lt; 8:\n                    escape = choice(&#91;1,1,1,0,0])\n                    if escape == 1:\n                        break\n                count += 1\n                if count &gt; 1000:\n                    return \"Endless recursion\"\n            alto_voice.append(note)\n\n        alto_voice = alto_voice\n        ela = choice(&#91;4,8])\n        #print(ela)\n        if ela == 4:\n            if s_elasticity_valid(alto_voice&#91;0:4],4) and s_elasticity_valid(alto_voice&#91;4:8],4):\n                break\n        else:\n            if s_elasticity_valid(alto_voice,8):\n                break\n        #break\n        alto_voice = &#91;]\n    #print(f\"{&#91;item + 12 for item in alto_voice]} this is alto_voice \")\n    \n\n    # ==== Alto line finish =================\n\n    # ==== Now go to the tenor line =====================================\n    cf = cf; bass_voice = bass_voice; alto_voice = alto_voice\n    tenor_voice = &#91;];range_lower = -6; range_higher = 7\n    while True:\n        #print(\"yes\")\n\n        for i in range(8):\n            note_selection_raw = &#91;]\n            # three stands for 3 octaves range\n            chord = cf_s_p_m_det&#91;i]\n            #print(chord)\n            for j in range(3):\n                for item in chord:\n                    note_selection_raw.append(item - 24 + j * 12)\n            existed = &#91;cf&#91;i],bass_voice&#91;i],alto_voice&#91;i]]\n            note_selection = &#91;]\n            for j in range(len(note_selection_raw)):\n                if note_selection_raw&#91;j] not in existed:\n                    note_selection.append(note_selection_raw&#91;j])\n            # now get rid of redundant notes\n            notes_selection_clear = &#91;]\n            for item in note_selection:\n                if item &gt; (bass_voice&#91;i] + 1) and item &lt; alto_voice&#91;i]:\n                    notes_selection_clear.append(item)\n\n            # now get the previous note of the melody, and if it is &lt; 5 100% accept, if &gt;5 &lt; 10, 60% accept, other 0% accept\n            if tenor_voice != &#91;]:\n                prev = tenor_voice&#91;-1]\n                count = 0\n                while True:\n                    #print(f\"{notes_selection_clear} this isnotes_selection_clear\")\n                    note = choice(notes_selection_clear)\n                    if abs(note - prev) &lt; 5:\n                        escape = choice(&#91;1])\n                        if escape == 1:\n                            break\n                    elif abs(note - prev) &gt; 5 and abs(note - prev) &lt; 8:\n                        escape = choice(&#91;1,0,0,0,0])\n                        if escape == 1:\n                            break\n                    count +=1\n                    if count &gt; 1000:\n                        return \"Endless recursion\"\n                tenor_voice.append(note)\n            else:\n                tenor_voice.append(choice(notes_selection_clear))\n        tenor_voice = tenor_voice\n        ela = choice(&#91;4,8])\n        #print(ela)\n        if ela == 4:\n            if s_elasticity_valid(alto_voice&#91;0:4],4) and s_elasticity_valid(alto_voice&#91;4:8],4):\n                break\n        else:\n            if s_elasticity_valid(alto_voice,8):\n                break\n        #break\n        tenor_voice = &#91;]\n    #print(f\"{&#91;item + 12 for item in tenor_voice]} this is tenor_voice \")\n    \n    return &#91;cf,alto_voice,tenor_voice,bass_voice]\n                 \ndef motionize(voices):\n    '''\n    accepting the 4 voices generated by the generate CP, now bestow the motion and make\n    the counterpoint alive!\n    '''\n    s_prime = voices&#91;0]; a_prime = voices&#91;1]; t_prime = voices&#91;2]; b_prime = voices&#91;3]\n    # form_num = 4\n    # # this is the piano roll for each voice\n    # s = &#91;0 for i in range(3*8*2*form_num)]\n    # a = &#91;0 for i in range(3*8*2*form_num)]\n    # t = &#91;0 for i in range(3*8*2*form_num)]\n    # b = &#91;0 for i in range(3*8*2*form_num)]\n    \n    chord_matrix = &#91;] # this contains the whole piano roll of the corpus\n    pc = &#91;s_prime&#91;0], a_prime&#91;0], t_prime&#91;0], b_prime&#91;0]]\n    chord_matrix.append(pc)\n    for i in range(1, len(s_prime)):\n        tc = &#91;s_prime&#91;i], a_prime&#91;i], t_prime&#91;i], b_prime&#91;i]]\n        inner_chord = return_inner_chord(&#91;pc,tc])\n        chord_matrix.append(inner_chord&#91;0])\n        chord_matrix.append(inner_chord&#91;1])\n        chord_matrix.append(tc)\n        pc = tc\n    # now the chord_matrix would be 2D filled with the chord\n    print(chord_matrix)\n    return chord_matrix\n        \ndef return_inner_chord(voices):\n    '''\n    return 2 bridges chord for the 2 prime chords\n    '''\n    # precedented chord\n    pc_s = voices&#91;0]&#91;0]; pc_a = voices&#91;0]&#91;1]; pc_t = voices&#91;0]&#91;2]; pc_b = voices&#91;0]&#91;3]\n    # target chord\n    tc_s = voices&#91;1]&#91;0]; tc_a = voices&#91;1]&#91;1]; tc_t = voices&#91;1]&#91;2]; tc_b = voices&#91;1]&#91;3]\n    # scale \n    tonic_scale = &#91;0,2,4,5,7,9,11]; dom_scale = &#91;0,2,4,6,7,9,11]; sec_dom_scale = &#91;1,2,4,6,7,9,11]\n    t_s_chord = &#91;&#91;0,4,7,12], &#91;2,5,9,12], &#91;4,7,11,14], &#91;5,9,12,16],&#91;7,11,14,17]]\n    # the function the index number of t_s_chord\n    T = &#91;t_s_chord&#91;0]]; PD = &#91;t_s_chord&#91;1], t_s_chord&#91;3]]; D = &#91;t_s_chord&#91;4]]; m = &#91;t_s_chord&#91;2]]; DD_chord = &#91;&#91;2, 6, 9, 12]];c_64_chord = &#91;&#91;7-12, 0, 4, 7]]\n\n    # chord spanner provides the lattices for the chord generation\n    chord_spanner = &#91;]\n    for item in t_s_chord:\n        temp = &#91;]\n        for i in range(6):\n            for item2 in item:\n                temp.append(item2 - 12*3 + 12*i)\n        chord_spanner.append(temp)\n    #print(chord_spanner)\n    # Tips: s and a can use neihbor tone and passing tone but t and b only can use passing tone\n    consonant_interval = &#91;3,4,8,9,5,7]\n    # this is the loop to check whether the 2 generated are correct chord in t_s_chord \n    i_s = 0; i_a = 0; i_t = 0; i_b = 0\n    ii_s = 0; ii_a = 0; ii_t = 0; ii_b = 0\n    i_chord = &#91;]; ii_chord = &#91;]\n    while True:\n        \n        # first try for any linearly interpolating in the soprano interval,\n        # be caustious on whether pc is larger than tc or equal to tc\n        i_s = i_s; pc_s = pc_s; tc_s = tc_s;\n        if pc_s != tc_s:\n            for num in range(pc_s,tc_s):\n                if (num%12) in tonic_scale:\n                    for i in range(len(t_s_chord)):\n                        if num%12 in t_s_chord&#91;i]:\n                            i_chord = t_s_chord&#91;i]\n                            break \n                if i_chord != &#91;]:\n                    i_s = num\n                    break\n            if i_chord == &#91;]:\n                i_chord = &#91;pc_s,pc_a,pc_t,pc_b]\n                i_s = pc_s\n        else:\n            i_s = pc_s\n            for item in t_s_chord:\n                if i_s%12 in item:\n                    i_chord = item\n                    break\n        # Once get an experimental i_s, try to assign i_atb with the first detected chord aligned with i_s\n\n        flag_a = False; flag_t = False; flag_b = False\n        while True:\n           # print(&#91;i_a,i_t,i_b,pc_a])\n           # print(i_chord)\n            for i in range(len(i_chord)):\n                for num in range(pc_a, tc_a):\n                    if (num%12) == (i_chord&#91;i]%12):\n                        #print(num)\n                        i_a = num\n                        flag_a = True\n                        break\n                for num in range(pc_t, tc_t):\n                    if (num%12) == (i_chord&#91;i]%12):\n                        i_t = num\n                        flag_t = True\n                        break\n                for num in range(pc_b, tc_b):\n                    if (num%12) == (i_chord&#91;i]%12):\n                        i_b = num\n                        flag_b = True\n                        break \n            #print(&#91;i_s,i_a,i_t,i_b])\n            if flag_a == True and flag_t == True and flag_b == True:\n               # print(\"yes\")\n                break  \n            else:\n                return &#91;&#91;pc_s, pc_a, pc_t, pc_b],&#91;pc_s, pc_a, pc_t, pc_b]]\n                i_s,i_a,i_t,i_b = pc_s, pc_a, pc_t, pc_b\n                i_chord = &#91;pc_s, pc_a, pc_t, pc_b]\n               # print(\"fuck\")\n                break\n\n        # After getting i_satb, try to do the same thing for ii_satb (just replace pc with i_satb)\n\n        if i_s != tc_s:\n            for num in range(i_s,tc_s):\n                if (num%12) in tonic_scale:\n                    for i in range(len(t_s_chord)):\n                        if num%12 in t_s_chord&#91;i]:\n                            ii_chord = t_s_chord&#91;i]\n                            break \n                if ii_chord != &#91;]:\n                    ii_s = num\n                    break\n            if ii_chord == &#91;]:\n                ii_chord = &#91;pc_s,pc_a,pc_t,pc_b]\n                ii_s = i_s\n        else:\n            ii_s = i_s\n            for item in t_s_chord:\n                if ii_s%12 in item:\n                    ii_chord = item\n                    break\n        # Once get an experimental i_s, try to assign i_atb with the first detected chord aligned with i_s\n\n        flag_a = False; flag_t = False; flag_b = False\n        while True:\n           # print(&#91;ii_a,ii_t,ii_b,pc_a])\n            #print(ii_chord)\n            for i in range(len(ii_chord)):\n                for num in range(i_a, tc_a):\n                    if (num%12) == (ii_chord&#91;i]%12):\n                        #print(num)\n                        ii_a = num\n                        flag_a = True\n                        break\n                for num in range(i_t, tc_t):\n                    if (num%12) == (ii_chord&#91;i]%12):\n                        ii_t = num\n                        flag_t = True\n                        break\n                for num in range(i_b, tc_b):\n                    if (num%12) == (ii_chord&#91;i]%12):\n                        ii_b = num\n                        flag_b = True\n                        break \n            #print(&#91;i_s,i_a,i_t,i_b])\n            if flag_a == True and flag_t == True and flag_b == True:\n                #print(\"yes\")\n                break  \n            else:\n                return &#91;&#91;i_s, i_a, i_t, i_b],&#91;i_s, i_a, i_t, i_b]]\n\n                #print(\"fuck\")\n                break\n        break\n\n    \n    return &#91;&#91;i_s,i_a,i_t,i_b], &#91;ii_s,ii_a,ii_t,ii_b]]\n\ndef soprano(q,l,keey,tempoo):\n    cyc1 = cycle(rhythm(\"q q\", tempo=tempoo))\n    rhy1 = next(cyc1)\n    rhy1 = next(cyc1)\n    #print(l)\n    for t in l:\n        rhy1 = next(cyc1)\n        note = MidiNote(time=q.now, dur=rhy1, amp=choice(&#91;0.7]), key=keey +12 +t, chan=0)\n        q.out.addevent(note)\n        yield rhy1\n\ndef alto(q,l,keey,tempoo):\n    cyc1 = cycle(rhythm(\"q q\", tempo=tempoo))\n    rhy1 = next(cyc1)\n    rhy1 = next(cyc1)\n    for t in l:\n        rhy1 = next(cyc1)\n        note = MidiNote(time=q.now, dur=rhy1, amp=choice(&#91;0.7]), key=keey +12 +t, chan=0)\n        q.out.addevent(note)\n        yield rhy1\n\ndef tenor(q,l,keey,tempoo):\n    cyc1 = cycle(rhythm(\"q q\", tempo=tempoo))\n    rhy1 = next(cyc1)\n    rhy1 = next(cyc1)\n    \n    for t in l:\n        rhy1 = next(cyc1)\n        note = MidiNote(time=q.now, dur=rhy1, amp=choice(&#91;0.7]), key=keey +12 +t, chan=0)\n        q.out.addevent(note)\n        yield rhy1\n\ndef bass(q,l,keey,tempoo):\n    cyc1 = cycle(rhythm(\"q q\", tempo=tempoo))\n    rhy1 = next(cyc1)\n    rhy1 = next(cyc1)\n    for t in l:\n        rhy1 = next(cyc1)\n        note = MidiNote(time=q.now, dur=rhy1, amp=choice(&#91;0.7]), key=keey +12 +t, chan=0)\n        q.out.addevent(note)\n        yield rhy1\n\ndef baroque():\n    t0 = MidiSeq.metaseq(ins={0: AcousticGrandPiano})\n    seq = MidiSeq();seq_2 = MidiSeq(); seq_3 = MidiSeq();seq_4 = MidiSeq();seq_5 = MidiSeq();keey = 60 + 9\n    tempoo = 40\n    queue = Scheduler(out=seq);queue_2 = Scheduler(out=seq_2);queue_3 = Scheduler(out=seq_3);queue_4 = Scheduler(out=seq_4);queue_5 = Scheduler(out=seq_5);\n    meta_four_voices = &#91;]\n    # now getting the list of the chord\n    while len(meta_four_voices) &lt; 1:\n        try:\n            a = generate_cp()\n        except:\n            continue\n        if len(a)==4:\n            meta_four_voices.append(a)\n        a = None\n\n    # temp decision\n    notess = meta_four_voices\n    #print(meta_four_voices)\n    notes = &#91;];s = &#91;]; a = &#91;]; t= &#91;]; b= &#91;]\n    for item in notess:\n        s = s + item&#91;0]; a = a + item&#91;1]\n        t = t + item&#91;2]; b = b + item&#91;3]      \n    notes = &#91;s,a,t,b]     \n    #temp_return = motionize(notes)\n    #print(len(s)); print(len(a)); print(len(t)); print(len(b))\n    queue.compose(&#91;0, soprano(queue, notes&#91;0],keey,tempoo)])\n    queue_2.compose(&#91;0, alto(queue_2, notes&#91;1],keey,tempoo)])\n    queue_3.compose(&#91;0, tenor(queue_3, notes&#91;2],keey,tempoo)])\n    queue_4.compose(&#91;0, bass(queue_4, notes&#91;3],keey,tempoo)])\n    queue_5.compose(&#91;0, bass(queue_5, &#91;item - 12 for item in notes&#91;3]],keey,tempoo)])\n    MidiFile(\"baroque.mid\", &#91;t0,seq,seq_2,seq_3,seq_4,seq_5]).write()  \n\nbaroque()<\/code><\/pre>\n","protected":false},"excerpt":{"rendered":"<p>Abstract: Muisca is an algorithmic composition that can generate functional four-part harmony based on the prescribed tessitura for each voice. Inside the algorithm, I implement multiple finite state machines with the probabilistic approach in different musical parameters controlling the transition of chord function(T, PD, D), scale degree(I, V, IV, etc.), and voice-leading rules(voice crossing, leap-recovery&hellip; <\/p>\n","protected":false},"author":1,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"spay_email":"","footnotes":""},"class_list":["post-477","page","type-page","status-publish","hentry"],"_links":{"self":[{"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/pages\/477","targetHints":{"allow":["GET"]}}],"collection":[{"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/comments?post=477"}],"version-history":[{"count":6,"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/pages\/477\/revisions"}],"predecessor-version":[{"id":689,"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/pages\/477\/revisions\/689"}],"wp:attachment":[{"href":"https:\/\/shichengzhang.web.illinois.edu\/wp-json\/wp\/v2\/media?parent=477"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}